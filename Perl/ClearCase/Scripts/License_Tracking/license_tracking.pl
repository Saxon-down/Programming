#!/user/bin/perl -w
##########################################################################
#                                                                        #
# license_tracking.pl                                                    #
# v1.5                                                                   #
# Garry Short, 13/06/08                                                  #
# perl@saxon-down.com    ##    http://www.saxon-down.com/scripts         #
#                                                                        #
# This script is designed to track the license usage of all IBM Rational #
# products and output the results to an HTML document which includes     #
# generated graphs. It is written specifically for v2007 and beyond of   #
# the tools.                                                             #
# You can specify DEBUGGING mode by running this script with the -DEBUG  #
# option (so ccperl license_tracking.pl -DEBUG)                          #
#                                                                        #
# HISTORY:                                                               #
# v1.5 13/06/08                                                          #
#      Minor bugfix to handle the license server being unavailable       #
# v1.4 19/05/08                                                          #
#      Minor bugfix to clean up some errant files                        #
# v1.3 08/05/08                                                          #
#      Added a little HTML to the output to align the charts nicely.     #
#      Also added an option to provide a -DEBUG flag for testing         #
# v1.2 01/05/08                                                          #
#      Fixed several bugs which were screwing up the html generation.    #
#      Also added rollover text for the graphs so that you can see how   #
#      many licenses are in use and how many are free and, where         #
#      applicable, who was using a license.                              #
# v1.1 24/04/08                                                          #
#      A complete rewrite from the ground up after seeing an ABS script  #
#      (which it's now based on) which performs a similar job.           #
# v0.1 21/04/08                                                          #
#      Initial version was written on a simpler basis; output was        #
#      written to text log files, and any charting had to be done via    #
#      Microsoft Excel                                                   #
#                                                                        #
##########################################################################

##########################################################################
#                                                                        #
# USEs, INCLUDEs, etc                                                    #
#                                                                        #
##########################################################################

use Time::localtime;


##########################################################################
#                                                                        #
# Global constants & variables                                           #
#                                                                        #
##########################################################################

# Constants
my $license_command = "lmutil lmstat -a";
my @hours_24 = (
  '08', '09', '10', '11', '12', '13', '14', '15', '16', '17'
);
my @hours_text = ( 
  '8am', '9am', '10am', '11am', '12pm', '1pm', '2pm', '3pm', '4pm', 
  '5pm'
);
my @mins_sections = ('00', '15', '30', '45');
my @days_text = (
  '40', '36', '32', '28', '24', '20', '16', '12', '8', '4'
);
my $root_path = "e:\\scripts\\license_tracking2\\";
my $error_file = $root_path . "license_tracking.log";


# Variables
my ($_run_duration,
  $_html_history_file,
  $_data_history_file,
  $_data_file,
  $trash,
  $error_time
);


##########################################################################
#                                                                        #
# Subroutines - HTML Generation                                          #
#                                                                        #
##########################################################################

sub Build_HTML_Chart {          # $which, $tool, $data
  # Generates the top-level chart, a 2x2 grid which other routines are then
  # called to populate.
  #
  my ($which, $tool, $data) = (@_);
  my (@html, $aref, $line);
  # At this level we want to build a 2x2 table; the population of each cell
  # is then farmed out to another subroutine
  push(@html,"<!-- Generated by Build_HTML_Chart -->");
  push(@html,"<h1>$tool license usage for $which</h1>");
  push(@html,"  <table cellpadding=0 cellspacing=0>");
  push(@html,"    <tr>");
  push(@html,"      <td>");     # Top left - y-axis
  # Generate and insert the code for the y-axis
  my $max = &Calculate_Overall_Max($data);
  $aref = &HTML_Table_Build_Y_Axis($max);
  foreach $line (@$aref) {
    $line = "        $line";    # Just keeps the HTML nicely indented
    push(@html, $line);
  }
  push(@html,"      </td>");
  push(@html,"      <td>");     # Top right - chart
  # Generate and insert the code for the table
  $aref = &HTML_Table_Build_Chart($data, $max, $which);
  foreach $line (@$aref) {
    $line = "        $line";
    push(@html, $line);
  }
  push(@html,"      </td>");
  push(@html,"    </tr>");
  push(@html,"    <tr>");
  push(@html,"      <td>");     # Bottom left - empty
  # Nothing really needs to go in here; might need to put some kind of 
  # spaceholder in, though
  push(@html,"      </td>");
  push(@html,"      <td>");     # Bottom right - x-axis
  # Generate and insert the code for the x-axis
  $aref = &HTML_Table_Build_X_Axis($which);
  foreach $line (@$aref) {
    $line = "        $line";
    push(@html, $line);
  }
  push(@html,"      </td>");
  push(@html,"    </tr>");
  push(@html,"  </table>");
  push(@html,"<P>&nbsp;</P>");
  push(@html,"<!-- END Build_HTML_Chart -->");
  return \@html;
}               # end Build_HTML_Chart


sub Generate_Table_Key {
  # Simply generates a key to describe how the colours are used in the 
  # previous tables. Doesn't need any data, just returns a chunk of HTML
  #
  my @html;
  push(@html,"<table>");
  push(@html,"  <tr height=20>");
  push(@html,"    <td background=../images/bar.gif><img src=../images/bar.gif>");
  push(@html,"    </td>");
  push(@html,"    <td>Licenses in use");
  push(@html,"    </td>");
  push(@html,"  </tr height=20>");
  push(@html,"  <tr height=20>");
  push(@html,"    <td background=../images/space.gif><img src=../images/space.gif>");
  push(@html,"    </td>");
  push(@html,"    <td>Licenses free");
  push(@html,"    </td>");
  push(@html,"  </tr height=20>");
  push(@html,"  <tr height=20>");
  push(@html,"    <td background=../images/extra.gif><img src=../images/extra.gif>");
  push(@html,"    </td>");
  push(@html,"    <td>Licenses that will be added later or were removed earlier in the timeline (or no data was recorded for that period)");
  push(@html,"    </td>");
  push(@html,"  </tr height=20>");
  push(@html,"</table>");
  return \@html;
}


sub HTML_Table_Build_Chart {            # $data_aref, $overall_max, $which
  # Builds the actual chart part of the table.
  #
  my ($data, $max_limit, $which) = (@_);
  my @return;
  my ($mouseover, $mouseover_text);
  push(@return,"<!-- Generated by HTML_Table_Build_Chart -->");
  push(@return,"<table border=1 bordercolor=#000000 cellspacing=0 cellpadding=0 width=100% height=100>");
  push(@return,"  <tr>");
  # A chart is 10 sections (hours for daily [8am-6pm], or days for history 
  # [40x10]). Each section is subdivided into 4 sections (15mins for daily,
  # 1 day for historic).
  foreach my $main (0..9) {
    push(@return,"    <td>");
    push(@return,"      <table width=40 height=100% cellspacing=0 cellpadding=0>");
    push(@return,"        <tr>");
    foreach my $sub (0..3) {
      my $count = ($main*4)+$sub;
      if (! @$data) {     # next if this is an empty array
        push(@return,"          <td width=10>");
        push(@return,"            <table cellspacing=0 cellpadding=0 height=100>");
        push(@return,"              <tr height=100><td background=../images/blank.gif><img src=../images/blank.gif></td></tr>");
        push(@return,"            </table>");
        push(@return,"          </td>");
      } else { 
        my $line = shift(@$data);
#      next if $line eq "";      # next if this is a blank line
        my ($time, $max, $cur, $users) = split /,/, $line;
        # Generate a timestamp which should be determined according to where
        # we are in the loop; it looks up the $main element of @hours_24 and
        # the $sub element of @mins_sections (both global variables defined
        # at the top of this script.
        my $loop_time = $hours_24[$main] . ":" . $mins_sections[$sub];
        if (($time eq $loop_time) or ($which eq "history")) {
          # The current line in the file matches the time index we're 
          # currently attempting to process.
          $free = $max - $cur;    # free licenses = maximum - currently used
          # $extra is used to display the difference between how many licenses
          # we own now, and the most we've ever owned (either because we've
          # bought more licenses or returned some.
          $extra = $max_limit - $max;
        } else {
          # The data for this time index is missing from the file, so put
          # the current data back at the beginning of the list and insert an 
          # empty column in the chart
          unshift(@$data,$line);
          $free = 0;
          $cur = 0;
          $extra = $max_limit;
        }
        # Would like to be able to mouseover each column to see the exact
        # numbers and a list of users if applicable, so the next 5 lines do
        # exactly that. The title gets imbedded into the column definition 
        # so that mouseover works anywhere within the given column
        $mouseover_text = "$cur license(s) in use, $free free. ";
        if ($users) { 
          $mouseover_text .= " Used by $users"; 
        }
        $mouseover = "title=\"$mouseover_text\"";
        # The chart's going to be 100 units high, so we need to scale
        # every value to fit within the 0-100 range.
        my $scale = 100/$max_limit;
        # seem to be getting slight rounding errors on specific charts,
        # so hoping to get rid of them by setting $max to 100 if it's the
        # same as the max_limit.
        my $scaled_max;
        if ($max == $max_limit) {
          $scaled_max = 100;
        } else {
          $scaled_max = int($max * $scale);
        }
        my $scaled_cur = int($cur * $scale);
        my $scaled_free = int($free * $scale);
#       my $scaled_free = $scaled_max - $scaled_cur;
        my $scaled_extra = int($extra * $scale);
#       my $scaled_extra = 100 - $scaled_max;
        push(@return,"          <td width=10>");
        push(@return,"            <table cellspacing=0 cellpadding=0 height=100>");
        if ($extra > 0) {
          push(@return,"              <tr height=$scaled_extra $mouseover><td background=../images/extra.gif><img src=../images/extra.gif></td></tr>");
        }
        if ($free > 0) {
          push(@return,"              <tr height=$scaled_free $mouseover><td background=../images/space.gif><img src=../images/space.gif></td></tr>");
        }
        if ($cur > 0) {
          push(@return,"              <tr height=$scaled_cur $mouseover><td background=../images/bar.gif><img src=../images/bar.gif></td></tr>");
        }
        push(@return,"            </table>");
        push(@return,"          </td>");
      }
    } 
    push(@return,"        </tr>");
    push(@return,"      </table>");
    push(@return,"    </td>");
  }
  push(@return,"  </tr>");
  push(@return,"</table>");
  push(@return,"<!-- Generated by HTML_Table_Build_Chart -->");
  return \@return;
}               # End HTML_Table_Build_Chart


sub HTML_Table_Build_X_Axis {   # $which
  # The only variations on this are what the labels are, depending on 
  # whether it's a daily (today / yesterday) or historical table
  #
  my ($which) = (@_);
  my (@return, @labels);
  if ($which eq "history") {   # historic
    @labels = @days_text;
  } else {
    @labels = @hours_text;
  }
  push(@return,"<!-- Generated by HTML_Table_Build_X_Axis -->");
  push(@return,"  <table cellpadding=0 cellspacing=0 width=100%>");
  push(@return,"    <tr>");
  foreach my $l (@labels) {     # Should generate 10 columns
    push(@return,"      <td align=left width=40>");
    push(@return,"        <font size=-2>$l</font>");
    push(@return,"      </td>");
  }
  push(@return,"    </tr>");
  push(@return,"  </table>");
  push(@return,"<!-- END HTML_Table_Build_X_Axis -->");
  return \@return;
}               # End HTML_Table_Build_X_Axis


sub HTML_Table_Build_Y_Axis {           # $max
  # This is the same regardless of what table we're building, so the only
  # thing we need to know is the maximum value
  #
  my ($max) = (@_);
  my @return;
  push(@return,"<!-- Generated by HTML_Table_Build_Y_Axis -->");
  push(@return,"<table cellpadding=0 cellspacing=0 border=0 bordercolor=#000000>");
  push(@return,"  <tr><td height=50 valign=top>$max</td></tr>");
  push(@return,"  <tr><td height=50 valign=bottom align=right>0</td></tr>");
  push(@return,"</table>");
  push(@return,"<!-- END HTML_Table_Build_Y_Axis -->");
  return \@return;
}               # End HTML_Table_Build_Y_Axis


##########################################################################
#                                                                        #
# Subroutines - Everything else                                          #
#                                                                        #
##########################################################################

sub Append_Daily_Data {         # $date_file, $date_time, $lmstat_data
  # Appends the data we've just generated to today's log. If this is the
  # first run of the day, it'll create a new file first.
  #
  my ($date, $time, $data) = (@_);
  foreach my $tool (sort keys %$data) { # for each tool in the data
    # Open the file so we can append data to it
    my $file = $_data_file;
    # Swap out the placeholders in the filename variable and swap in the
    # required information
    $file =~ s/WHICHTOOL/$tool/;
    $file =~ s/WHICHDATE/today/;
    open FILE, ">>$file" or 
                        &Log_Error("Append_Daily_Data:: Can't open file $file: $!\n");
    my $aref = $$data{$tool};           # .. Get the reference it stores
    my ($max, $cur, $users) = (@$aref); # .. and turn it into readable data
    print FILE "$time,$max,$cur,$users\n";
    # The line we've just printed should be of the form:
    #   "10:30,10,3,bugs.bunny daffy.duck mickey.mouse"
    # Each new tool data should be appended to the current line
    close FILE;
  }
}               # End Append_Daily_Data


sub Append_Data_to_File {       # $file, $data
  # Takes a filename and a string and appends the data to the file.
  #
  my ($file, $data) = (@_);
    open FILE, ">>$file" or &Log_Error("Append_Data_to_File:: Can't append to $file: $!\n");
    print FILE $data;
    close FILE;
}               # end Append_Data_to_File


sub Append_Historical_Data {    # $lmstat_data, $date
  # Goes through each of today's data files and finds the maximum values of
  # total licenses and used licenses. It then writes this information to the
  # history file
  #
  my ($href, $date) = (@_);
  # Don't actually need the lmstat data, it's just a handy way of getting
  # the tool names (which are used as part of the filenames)
  foreach my $tool (sort keys %$href) { # foreach tool ..
    my $hist = $_data_history_file;
    $hist =~ s/WHICHTOOL/$tool/;        # Build the actual history filename
    my $today = $_data_file;
    $today =~ s/WHICHTOOL/$tool/;       # Build the actual today filename
    $today =~ s/WHICHDATE/today/;
    my $daily = &Read_Data_File_to_Array($today);
    my $max_total = $max_current = 0;
    foreach my $line (@$daily) {         # Get the highest values for today
                                        # of total and used licenses
      my ($total, $current) = (split /,/, $line)[1,2];
      $max_total = $total if ($max_total < $total);
      $max_current = $current if ($max_current < $current);
    }
    # Now we've got the today's maximums, write them to the history file
    &Append_Data_to_File($hist, "$date,$max_total,$max_current\n");
  }
}               # End Append_Historical_Data


sub Backup_and_Blank {          # $tool, $type (one of "data" or "html")
  # Back up today's data to yesterday's file and then blank today's file, 
  # ready for tomorrow.
  #
  my ($tool, $type) = (@_);
  my ($today, $yesterday);
  if ($type eq "data") {
    $today = $yesterday = $_data_file;
  } elsif ($type eq "html") {
    $today = $root_path . "web_results\\today.html";
    $yesterday = $root_path . "web_results\\yesterday.html";
  } else {
    # This should never happen, since it's only called internally and means
    # I've messed up somehow.
    &Log_Error("Backup_and_Blank:: You've provided an invalid argument [$type]");
  }
  # Now substitute $tool into the filenames we have
  $today =~ s/WHICHTOOL/$tool/;
  $yesterday =~ s/WHICHTOOL/$tool/;
  # Substitute either "today" or "yesterday" into the filenames
  $today =~ s/WHICHDATE/today/;
  $yesterday =~ s/WHICHDATE/yesterday/;
  # Read today's file into memory
  open TODAY, $today or &Log_Error("Backup_and_Blank:: Can't read TODAY $today: $!\n");
  my @file = <TODAY>;
  close TODAY;
  # Now blank out today's file, ready for tomorrow
  open TODAY, ">$today" or &Log_Error("Backup_and_Blank:: Can't write to TODAY $today: $!\n");
  print TODAY "";
  close TODAY;
  # Write today's data from memory to yesterday's file
  open YESTERDAY, ">$yesterday" or &Log_Error("Backup_and_Blank:: Can't rewrite YESTERDAY $yesterday: $!\n");
  print YESTERDAY @file;
  close YESTERDAY;
}               # End Backup_and_Blank


sub Build_Page {                # $which
  # Builds a whole page of tables at a time (either for today, yesterday, 
  # or history. Takes $which, an argument defining which of the three 
  # options is being requested. From that it works out which files need
  # to be read and sequentially reads them and requests for the data to
  # be tabulated.
  #
  my ($which) = (@_);
  my @list_of_arefs;
  # Grab a list of files matching the criteria that's been passed.
  opendir(DIR, $root_path . "data");
  @files = grep(/$which/, readdir(DIR));
  closedir DIR;
  # for each of those files, read the data in and get that individual table
  # generated
  foreach my $file (@files) {
    # To get the name of the tool, take the filename and grab everything
    # before the first underscore
    my ($tool) = (split /_/, $file)[0];
    open FILE, $root_path . "data\\$file" or 
                &Log_Error("Build_Page:: Can't read file $file: $!\n");
    chomp(my @html_data = <FILE>);
    close FILE;
    if ($which eq "history") {
      # History's a bit more complicated, since we only want the last 40 
      # days of data; if there's <40 days, the data needs to be padded out
      @html_data = &Massage_History_Data(@html_data);
    }
    push(@list_of_arefs, &Build_HTML_Chart($which, $tool, \@html_data));
  }
  # Write each of the tables to the output file
  open FILE, ">$root_path" . "web_results\\$which.html" or 
                &Log_Error("Build_Page:: can't write to FILE $which: $!\n");
  print FILE "<table>\n";
  foreach my $aref (@list_of_arefs) {
    print FILE "<tr align=right>\n";
    print FILE "<td>\n";
    foreach my $line (@$aref) {
      print FILE "$line\n";
    }
    print FILE "</td>\n";
    print FILE "</tr>\n";
  }
  print FILE "</table>\n";
  # write the chart key to the output file (the "this colour means this"
  # section).
  my $key = &Generate_Table_Key;
  foreach my $line (@$key) {
    print FILE "$line\n";
  }
  close FILE;
}


sub Calculate_Overall_Max {             # $data_aref
  # Takes an array of data that's been read from a file and scans it to
  # calculate the highest max_licenses value.
  #
  my ($aref) = (@_);
  my $return = 0;
  foreach my $line (@$aref) {
    my ($max) = (split /,/, $line)[1];
    $return = $max if $max > $return;
  }
  return $return;
}


sub Check_For_Dirs {
  # Checks for the existence of the directories we expect, and creates them
  # if necessary (with global RWX permissions)
  #
  my $path;
  my @req_folders = (
    "data", "web_results" 
  );
  foreach my $opt (@req_folders) {
    $path = $root_path . $opt;
    if (! -e $path) {
      mkdir($path, 0777) or 
        &Log_Error("Check_For_Dirs:: Can't create $path directory: $!\n");
    }
  }
}               # End Check_For_Dirs


sub Convert_Data_Array_to_Hash {        # $aref of data_file
  # Takes an array that's been read in from a data file and converts it 
  # into a hash (where the date/time is the key)
  #
  my ($aref) = (@_);
  my %return;
  foreach my $line (@$aref) {
    my ($datetime, $max, $cur, $users) = split /,/, $line;
    $return{$datetime} = "$max,$cur,$users";
  }
  return \%return;
}               # End Convert_Data_Array_to_Hash


sub End_Of_Day {        # $lmstat_data, $date
  # This is used to perform any tasks that need doing when this script 
  # finishes for the day
  #
  my ($href, $date) = (@_);
  &Append_Historical_Data($href, $date);
  # Reset all the daily logfiles, ready for tomorrow
  foreach my $tool (sort keys %$href) {
    &Backup_and_Blank($tool, "data");
    &Backup_and_Blank($tool, "html");
  }
}               # End End_Of_Day


sub Generate_Timestamps {
  # Uses localtime to generate 4 different timestamps: 
  #     1. Just the time (hh:mm)
  #     2. A sortable date (yyyy/mm/dd)
  #     3. A printable date (dd/mm/yy)
  #     4. A filename-compatible date (yyyy_mm_dd);
  # Return all 3 in a hashref.
  #
  my $time = localtime;
  my %results;
  # Only care about the 2nd-6th elements of the array returned by localtime
  my ($min, $hour, $date, $mon, $year) = (@$time)[1..5];
  my $print_year = $year - 100;
  $mon++;               # The month is returned in the 0-11 range
  $year += 1900;        # The year returned is the number passed since 1900
  # for each of mon, min, hour, print_year, force it to a 2-digit format
  # e.g. if the time's 5 past 9, force it to display 09:05 rather than 9:5
  $print_year = sprintf "%02d", $print_year;
  # sprintf performs a formatted print - in the case we're using here, it
  # forces all numbers to be displayed as 2 digits, with a leading 0 if
  # required.
  $mon = sprintf "%02d", $mon;
  $hour = sprintf "%02d", $hour;
  $min = sprintf "%02d", $min;
  $date = sprintf "%02d", $date;
  # Now populate the hash we'll return ..
  $results{"date_time"} = "$hour:$min";                         # hh:mm
  $results{"date_sort"} = "$year/$mon/$date";                   # yyyy/mm/dd
  $results{"date_print"} = "$date/$mon/$print_year";            # dd/mm/yy
  $results{"date_file"} = $year . "_" . $mon . "_" . $date;     # yyyy_mm_dd
  # .. and return it to the calling function
  return \%results;
}               # End Generate_Timestamps


sub Get_License_Usage {
  # runs $license_command to determine the current license usage.
  #
  my %results;
  my ($tool, $max_licenses, $used_licenses);
  my @user_list = ();
  my @output = qx/$license_command/;    # collects output in an array
  foreach my $line (@output) {          # process the command output
    if ($line =~ /^Users of/) {         # We've found a new license type
      # Only care about 3 pieces of information: what the license is,
      # what the maximum is and what the current usage is. Given the line
      # is of the format:
      # Users of <TOOL>:  (Total of <X> licenses issued;  Total of <Y> licenses in use)
      # .. we know that if we split it by whitespace, we want the 3rd 
      # (<TOOL>), 7th (<X>) and 13th (<Y>) elements.
      ($tool, $max_licenses, $used_licenses) = (split / /, $line)[2,6,12];
      $tool =~s/:$//;                   # Strip the unwanted : off 
      @userlist = ();                   # New tool, so reset user list
    } elsif ($line =~ /^    /) {        # We've found a user of the current
                                        # license type
      $line =~ s/^    ([\w.]*).*\n$/$1/;# Strip out all but the login
      push (@userlist, $line);          # .. and add it to the list
    } elsif ($line =~ /The desired vendor daemon is down/) { 
      # The license server is down; need to get a list of the files to
      # update
      # Read the data directory to see which files we need to update
      &Log_Error("Licensing server is down");
      opendir(DIR, $root_dir . "data");
      my @files = grep(/today_data\.txt/, readdir(DIR));
      closedir DIR;
      # Populate the data hash that we'd normally dump the license results
      # into with null data
      foreach my $f (@files) {
        $f = (split /_/,$f)[0];
        chomp $f;
        $results{$f} = [0,0,""];
      }
    }else {
      my $users;
      # Not a tool, not a user, so store the results
      if (@userlist) {                  # We have a user list, so ..
        @userlist = sort @userlist;     # sort it ..
        $users = join(" ", @userlist);  # .. and convert to a string
      } else {
        $users = "";                    # No userlist, so give empty string
      }
      if ($max_licenses) {
        $results{$tool} = [$max_licenses, $used_licenses, $users];
      }
      next;                             # Don't care about this line
    }
  }
  return \%results;                     # Pass back a reference
}               # End Get_License_Usage


sub Log_Error {                  # $string
  # Used to log errors to file, rather than using DIE
  #
  my ($string) = (@_);
  open FILE, ">>$error_file";
  my $times = &Generate_Timestamps();
  my $error_time = $$times{"date_print"} . " " . $$times{"date_time"};
  print FILE "$error_time  $string";
  close FILE;
}               # End Log_Error


sub Massage_History_Data {       # @data
  # When printing a historic chart, we display 40 days of data. If there's
  # less data than 40 days, we need to pad it out. If there's more, we
  # need to trim it
  #
  my (@data) = (@_);
  my $length = $#data + 1;
  if ($length < 40) {           # Not enough data ..
    foreach (($length+1)..40) { # .. so pad it out
      unshift(@data, "NULL,0,0");
    }
  } elsif ($length > 40) {      # Too much data ..
    foreach (1..($length-40)) { # .. so trim it
      shift(@data);
    }
  }
  return @data;
}


sub Read_Data_File_to_Array {    # history or day data file
  # Reads the given file into an array and returns a reference to it.
  #
  my ($file) = (@_);
  my @return;
  open FILE, $file or &Log_Error("Read_Data_File_to_Array:: Can't read file $file: $!\n");
  chomp (@return = <FILE>);
  close FILE;
  return \@return;
}               # End Read_Data_File_to_Array


sub Set_Environment_Specifics {         # $date
  # We've a number of path+filename variables, which need to be different
  # depending on whether we're running on Windows or UNIX. We'll default
  # everything on the assumption that we're running Windows, check to see 
  # if we're right, and if we're not, modify the paths to use / instead
  # of /
  #
  my ($d) = (@_);               # Get the date we should have been passed
  my $OS = "$ENV{'OS'}";        # Get the operating system
  my @generic = (               # Set up the variables for Windows
    $root_path . "run_duration.txt",
    $root_path . "web_results\\WHICHTOOL_history.html",
    $root_path . "data\\WHICHTOOL_history_data.txt",
    $root_path . "data\\WHICHTOOL_WHICHDATE_data.txt"
  );
  $trash = "NUL";
  if ($OS !~ /[Ww]indows/) {    # Okay, we got it wrong, so ...
    foreach my $element (@generic) {
      $element =~ s/\\/\//;     # .. change the \ to / ..
    }
    $trash = "/dev/null";       # .. and use the right NUL environment
  }
  # Now set the global variables to what we know is correct.
  $_run_duration        = $generic[0];
  $_html_history_file   = $generic[1];
  $_data_history_file   = $generic[2];
  $_data_file           = $generic[3];
}               # End Set_Environment_Specifics


##########################################################################
#                                                                        #
# Main                                                                   #
#                                                                        #
##########################################################################

{
  if ($ARGV[0] eq "-DEBUG") {           # We're in DEBUGGING mode, so ...
    $root_path = $root_path . "DEBUG\\";# .. change the output to our ..
    $error_file =~ s/king2/king2\\DEBUG/;       #       .. DEBUGGING area
    print "DEBUG Mode... output changed to '$root_path'\n";            
    print "DEBUG Mode... Logging changed to $error_file\n";
  }
  my $href = &Generate_Timestamps;
  my $date = $$href{"date_file"};
  my $time = $$href{"date_time"};
  my $fulldate = $$href{"date_print"};
  $error_time = "$time $fulldate";
  &Set_Environment_Specifics($date);
  &Check_For_Dirs;
  my ($hour) = (split /:/, $time)[0];
  if ($hour > 20) {     # Just need to do the end_of_day stuff 
    &Log_Error("End of Day cleanup [$time]\n");
    &End_Of_Day(&Get_License_Usage, $fulldate);
    &Build_Page("yesterday");
    &Build_Page("history");
  } else {              # Logging data, but don't need the end_of_day yet
    &Log_Error("Daily run\n");
    &Append_Daily_Data($date,$time,&Get_License_Usage);
    if ($ARGV[0] eq "-DEBUG") {         # We're in DEBUGGING mode, so ..
      &End_Of_Day(&Get_License_Usage, $fulldate);
      &Build_Page("yesterday");
      &Build_Page("history");
      print "Debugging: generated 'yesterday' and 'history' pages\n";
    }
  }
  &Build_Page("today");
}               # End Main



